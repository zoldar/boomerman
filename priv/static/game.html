<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">

  <title>Bomberman</title>
  <meta name="description" content="A very simple Bomberman clone">
  <meta name="author" content="Adrian Gruntkowski">
  <style type="text/css">
    @font-face {
      font-family: pixeloid;
      src: url('fonts/pixeloidmono.ttf');
    }

    html,
    body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background-color: black;
      touch-action: none;
    }

    .sheet {
      display: none;
    }

    #stage {
      width: 100%;
      border: 1px solid lightgrey;
    }

    canvas {
      width: 100%;
      max-height: 100%;
      object-fit: contain;
      position: absolute;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    #ui-layer {
      z-index: 3;
    }

    #game-layer {
      z-index: 2;
    }

    #bg-layer {
      z-index: 1;
    }

    #menu {
      font-family: pixeloid, courier new, mono;
      font-size: x-large;
      position: fixed;
      bottom: 0.2rem;
      right: 0.2rem;
      z-index: 4;
      color: white;
    }

    #menu a {
      color: white;
    }
  </style>
</head>

<body>
  <img alt="Letter Spritesheet" class="sheet" id="letter-sheet" src="images/sharp-retro.png">
  <img alt="City Spritesheet" class="sheet" id="city-sheet" src="images/city.png">
  <img alt="Bombermen Spritesheet" class="sheet" , id="bombermen-sheet" src="images/bombermen.png">
  <img alt="Enemies Spritesheet" class="sheet" id="enemies-sheet" src="images/enemies.png">
  <img alt="Items Spritesheet" class="sheet" id="items-sheet" src="images/items.png">

  <div id="stage">
    <canvas id="ui-layer" width="320" height="200"></canvas>
    <canvas id="game-layer" width="320" height="200"></canvas>
    <canvas id="bg-layer" width="320" height="200"></canvas>
  </div>
  <div id="menu">
    <a href="?multi">MULTIPLAYER</a>
    |
    <a href="?single">SINGLE PLAYER</a>
  </div>

  <script>
    "use strict";

    // Helper class definitions
    class Point {
      x;
      y;

      constructor(x, y) {
        this.x = x;
        this.y = y;
      }

      add(p) {
        return new Point(this.x + p.x, this.y + p.y);
      }

      multiply(n) {
        return new Point(this.x * n, this.y * n);
      }

      divide(n) {
        return new Point(this.x / n, this.y / n);
      }

      round(n) {
        return new Point(Math.round(this.x), Math.round(this.y));
      }

      equals(p) {
        return Math.abs(this.x - p.x) < 0.00001 && Math.abs(this.y - p.y) < 0.00001;
      }

      hash() {
        return this.x + '#' + this.y;
      }

      vertical() {
        return this.x == 0 && this.y != 0;
      }

      horizontal() {
        return this.x != 0 && this.y == 0;
      }

      direction() {
        return this.divide(this);
      }

      directionName() {
        if (this.x > 0 && this.y == 0) return 'right';
        if (this.x < 0 && this.y == 0) return 'left';
        if (this.x == 0 && this.y > 0) return 'down';
        if (this.x == 0 && this.y < 0) return 'up';
        return 'none';
      }
    }

    class BoundingBox {
      position;
      width;
      height;

      constructor(position, width, height) {
        this.position = position;
        this.width = width;
        this.height = height;
      }

      hash() {
        return `${this.position.x}#${this.position.y}#${this.width}#${this.height}`;
      }
    }

    class HashSet {
      hashMap = new Map();

      constructor(iterable) {
        if (iterable) {
          let contents = iterable.map(o => [o.hash(), o]);
          this.hashMap = new Map(contents);
        }
      }

      add(o) {
        this.hashMap.set(o.hash(), o);
      }

      get(o) {
        return this.hashMap.get(o.hash());
      }

      delete(o) {
        this.hashMap.delete(o.hash());
      }

      clear() {
        this.hashMap.clear();
      }

      toArray() {
        return Array.from(this.hashMap.values());
      }

      has(o) {
        return this.hashMap.has(o.hash());
      }

      forEach(fun) {
        let idx = 0;
        this.hashMap.forEach((value) => {
          fun(value, idx);
          idx++;
        });
      }

      get size() {
        return this.hashMap.size;
      }
    }

    const TILE_SIZE = 16;
    const PLAYER_VELOCITY = 48;
    const POWERUP_VELOCITY = 72;
    const ENEMY_VELOCITY = 24;
    const SLIDE_VELOCITY = 60;
    const POWERUP_SECONDS = 20;
    const UP = new Point(0, -1);
    const DOWN = new Point(0, 1);
    const LEFT = new Point(-1, 0);
    const RIGHT = new Point(1, 0);

    function collides(box1, box2) {
      return box1.position.x < box2.position.x + box2.width &&
        box1.position.x + box1.width > box2.position.x &&
        box1.position.y < box2.position.y + box2.height &&
        box1.position.y + box1.height > box2.position.y;
    }

    function fullBoundingBox(position) {
      return { position: position, width: TILE_SIZE, height: TILE_SIZE };
    }

    function smallBoundingBox(position) {
      let offset = TILE_SIZE / 3;

      return {
        position: new Point(position.x + offset, position.y + offset),
        width: offset,
        height: offset
      }
    }

    class StaticTile {
      position;
      sprite;
      boundingBox;
      visible = true;

      constructor(position, sprite) {
        this.position = position;
        this.sprite = sprite;
        this.boundingBox = fullBoundingBox(position);
      }

      hash() {
        return this.position.x + "#" + this.position.y;
      }
    }

    let bgCanvas;
    let bgContext;
    let uiCanvas;
    let uiContext;
    let gameCanvas;
    let gameContext;
    let oldTimeStamp = 0;
    let keys = {};
    let mouseX = 0;
    let mouseY = 0;
    let clickHandlers = new Map();
    let keyHandlers = new Map();
    let keyUpEvent;

    const letterSheet = document.getElementById('letter-sheet');

    const mapSheet = {
      height: 16,
      sheet: document.getElementById('city-sheet'),
      '[': [0, 1],
      ']': [0, 8],
      '{': [2, 1],
      '}': [2, 7],
      '@': [1, 1],
      'O': [2, 8],
      '%': [0, 3],
      '#': [2, 2],
      'G': [2, 3],
      'S': [1, 3],
      'C': [0, 4],
      'bomb1': [4, 0],
      'bomb2': [4, 1],
      'bomb3': [4, 2],
      'explosion1': [5, 5],
      'explosion2': [5, 6],
      'explosion3': [5, 7],
      'explosion4': [6, 4],
      'blast_vertical1': [6, 5],
      'blast_vertical2': [6, 6],
      'blast_vertical3': [6, 7],
      'blast_vertical4': [7, 2],
      'blast_horizontal1': [5, 0],
      'blast_horizontal2': [6, 0],
      'blast_horizontal3': [7, 0],
      'blast_horizontal4': [5, 2],
      'blast_up1': [4, 7],
      'blast_up2': [4, 6],
      'blast_up3': [4, 5],
      'blast_up4': [4, 4],
      'blast_down1': [7, 5],
      'blast_down2': [7, 6],
      'blast_down3': [7, 7],
      'blast_down4': [7, 4],
      'blast_left1': [3, 4],
      'blast_left2': [3, 3],
      'blast_left3': [3, 2],
      'blast_left4': [3, 1],
      'blast_right1': [5, 1],
      'blast_right2': [6, 1],
      'blast_right3': [7, 1],
      'blast_right4': [5, 3]
    }

    const itemSheet = {
      height: 16,
      sheet: document.getElementById('items-sheet'),
      'speed_powerup': [2, 1],
      'speed_powerup2': [3, 1],
      'surprise_powerup': [4, 2],
      'surprise_powerup2': [5, 2],
      'blast_powerup': [0, 3],
      'blast_powerup2': [1, 3],
      'bomb_powerup': [0, 0],
      'bomb_powerup2': [1, 0],
      'confused_powerup': [0, 5],
      'confused_powerup2': [1, 5]
    };

    const enemySheet = {
      height: 25,
      sheet: document.getElementById('enemies-sheet'),
      'walk_down1': [1, 0],
      'walk_down2': [1, 1],
      'walk_down3': [1, 2],
      'walk_down4': [1, 3],
      'walk_down5': [1, 4],
      'walk_down6': [1, 5],
      'walk_down7': [1, 6],
      'walk_down8': [1, 7],
      'walk_down9': [1, 8],
      'walk_up1': [2, 0],
      'walk_up2': [2, 1],
      'walk_up3': [2, 2],
      'walk_up4': [2, 3],
      'walk_up5': [2, 4],
      'walk_up6': [2, 5],
      'walk_up7': [2, 6],
      'walk_up8': [2, 7],
      'walk_up9': [2, 8],
      'walk_left1': [3, 0],
      'walk_left2': [3, 1],
      'walk_left3': [3, 2],
      'walk_left4': [3, 3],
      'walk_left5': [3, 4],
      'walk_left6': [3, 5],
      'walk_left7': [3, 6],
      'walk_right1': [4, 0],
      'walk_right2': [4, 1],
      'walk_right3': [4, 2],
      'walk_right4': [4, 3],
      'walk_right5': [4, 4],
      'walk_right6': [4, 5],
      'walk_right7': [4, 6]
    };

    const bombermanSheet = {
      height: 25,
      sheet: document.getElementById('bombermen-sheet'),
      'white_walk_up1': [0, 0],
      'white_walk_up2': [0, 1],
      'white_walk_up3': [0, 2],
      'white_walk_left1': [1, 0],
      'white_walk_left2': [1, 1],
      'white_walk_left3': [1, 2],
      'white_walk_down1': [1, 3],
      'white_walk_down2': [1, 4],
      'white_walk_down3': [1, 5],
      'white_walk_right1': [1, 6],
      'white_walk_right2': [1, 7],
      'white_walk_right3': [1, 8],
      'red_walk_up1': [4, 0],
      'red_walk_up2': [4, 1],
      'red_walk_up3': [4, 2],
      'red_walk_left1': [5, 0],
      'red_walk_left2': [5, 1],
      'red_walk_left3': [5, 2],
      'red_walk_down1': [5, 3],
      'red_walk_down2': [5, 4],
      'red_walk_down3': [5, 5],
      'red_walk_right1': [5, 6],
      'red_walk_right2': [5, 7],
      'red_walk_right3': [5, 8],
    }

    const sheets = {
      'map': mapSheet,
      'bombermen': bombermanSheet,
      'enemies': enemySheet,
      'items': itemSheet
    };

    let playerAnimations = {
      sheet: 'bombermen',
      'stand_up': ['white_walk_up2'],
      'walk_up': ['white_walk_up3', 'white_walk_up1', 'white_walk_up2'],
      'stand_down': ['white_walk_down2'],
      'walk_down': ['white_walk_down3', 'white_walk_down1', 'white_walk_down2'],
      'stand_right': ['white_walk_right1'],
      'walk_right': ['white_walk_right2', 'white_walk_right3', 'white_walk_right1'],
      'stand_left': ['white_walk_left1'],
      'walk_left': ['white_walk_left2', 'white_walk_left3', 'white_walk_left1']
    };

    let enemyAnimations = {
      sheet: 'ememies',
      'stand_up': ['walk_up2', 'walk_up1', 'walk_up9', 'walk_up1'],
      'walk_up': ['walk_up1', 'walk_up2', 'walk_up3', 'walk_up4', 'walk_up5', 'walk_up6', 'walk_up7', 'walk_up8', 'walk_up9'],
      'stand_down': ['walk_down2', 'walk_down1', 'walk_down9', 'walk_down1'],
      'walk_down': ['walk_down1', 'walk_down2', 'walk_down3', 'walk_down4', 'walk_down5', 'walk_down6', 'walk_down7', 'walk_down8', 'walk_down9'],
      'stand_right': ['walk_right1', 'walk_right7'],
      'walk_right': ['walk_right1', 'walk_right2', 'walk_right3', 'walk_right4', 'walk_right5', 'walk_right6', 'walk_right7'],
      'stand_left': ['walk_left1', 'walk_left7'],
      'walk_left': ['walk_left1', 'walk_left2', 'walk_left3', 'walk_left4', 'walk_left5', 'walk_left6', 'walk_left7'],
    };

    let networkEnemyAnimations = {
      sheet: 'bombermen',
      'stand_up': ['red_walk_up2'],
      'walk_up': ['red_walk_up3', 'red_walk_up1', 'red_walk_up2'],
      'stand_down': ['red_walk_down2'],
      'walk_down': ['red_walk_down3', 'red_walk_down1', 'red_walk_down2'],
      'stand_right': ['red_walk_right1'],
      'walk_right': ['red_walk_right2', 'red_walk_right3', 'red_walk_right1'],
      'stand_left': ['red_walk_left1'],
      'walk_left': ['red_walk_left2', 'red_walk_left3', 'red_walk_left1']
    }

    let map0 = [
      "[%%%%%%%%%%%%%%%%%%]",
      "@ESSCSSSSCESSSSSSSEO",
      "@G#G#C#G#G#G#GGGGGGO",
      "@GGCGCGEGGGGGCGGGGGO",
      "@G#G#C#C#G#G#G[%%]GO",
      "@GGGGGGGGCGGGG@  OGO",
      "@G#G#G#G#C#G#G@  OGO",
      "@GGGGGGGCGGGGG{##}GO",
      "@G#G#G#G#G#G#GGGGGGO",
      "@EGGCGGGECCCCGGGGGPO",
      "{##################}"
    ];

    let wallSprites = new Set(['@', 'O', '#', '%', '{', '}', '[', ']']);

    class Enemy {
      spawnPoint;
      position;
      direction = DOWN;
      velocity = 0;
      boundingBox;
      hitBox;

      constructor(spawnPoint, socket) {
        this.sprite = socket ? 'red_walk_down2' : 'walk_down1';
        this.spawnPoint = spawnPoint;
        this.setPosition(spawnPoint);
      }

      setPosition(position) {
        this.position = position;
        this.boundingBox = fullBoundingBox(position);
        this.hitBox = smallBoundingBox(position);
      }

      atPosition(position) {
        let atEnemy = new Enemy(position);
        atEnemy.turn(this.direction);
        return atEnemy;
      }

      turn(direction) {
        this.direction = direction;
      }

      equals(e) {
        return e.hash() == this.hash();
      }

      hash() {
        return this.spawnPoint.x + "#" + this.spawnPoint.y;
      }
    }

    class Player {
      spawnPoint;
      position;
      direction;
      velocity = 0;
      powerups = new HashSet();
      boundingBox;
      hitBox;
      // set by animation loop
      sprite = 'white_walk_down1';

      constructor(position, direction) {
        this.spawnPoint = position;
        this.setPosition(position);
        this.turn(direction);
      }

      setPosition(position) {
        this.position = position;
        this.boundingBox = fullBoundingBox(position);
        this.hitBox = smallBoundingBox(position);
      }

      atPosition(position) {
        let atPlayer = new Player(position);
        atPlayer.turn(this.direction);
        return atPlayer;
      }

      turn(direction) {
        this.direction = direction;
      }
    }

    window.onload = init;

    function init() {
      // Get a reference to the canvas
      uiCanvas = document.getElementById('ui-layer');
      uiContext = uiCanvas.getContext('2d');
      gameCanvas = document.getElementById('game-layer');
      gameContext = gameCanvas.getContext('2d');
      bgCanvas = document.getElementById('bg-layer');
      bgContext = bgCanvas.getContext('2d');

      setupControls();

      var game = { loading: true };

      if (window.location.search == '?multi') {
        const protocol = window.location.protocol == 'http:' ? 'ws:' : 'wss:';
        const host = window.location.host;
        const socketUrl = protocol + "//" + host + "/socket/websocket";

        const socket = new WebSocket(socketUrl);

        socket.addEventListener("open", (event) => {
          socket.send("register");
        });

        socket.addEventListener("message", (event) => {
          if (event.data == "ping") {
            socket.send("pong");
          } else {
            let message = JSON.parse(event.data);

            if (message.action == 'registered') {
              let playerPostion = new Point(message.x, message.y).multiply(TILE_SIZE);
              let otherPlayers =
                message.players.map(p => {
                  return {
                    slot: new Point(p.slot.x, p.slot.y).multiply(TILE_SIZE),
                    position: new Point(p.position.x, p.position.y)
                  }
                });

              game = loadGame(message.map, playerPostion, otherPlayers, socket);

              startGame(game);
            } else if (!game.loading && message.action == 'player_joined') {
              game.enemies.add(new Enemy(new Point(message.x, message.y).multiply(TILE_SIZE), socket));
            } else if (!game.loading && message.action == 'player_left') {
              game.enemies.delete(new Enemy(new Point(message.x, message.y).multiply(TILE_SIZE)));
            } else if (!game.loading && message.action == 'game_lost') {
              game.state = 'lost';
              drawLost(game);
            } else if (!game.loading && message.action == 'game_won') {
              game.loading = true;
              game.state = 'won';
              stopGame(game);
              drawWon(game);
            } else if (!game.loading && message.action == 'game_will_restart') {
              game.loading = true;
              game.state = 'will_restart';
              stopGame(game);
              drawWillRestart(game);
            } else if (message.action == 'game_started') {
              let playerPostion = new Point(message.x, message.y).multiply(TILE_SIZE);
              let otherPlayers =
                message.players.map(p => {
                  return {
                    slot: new Point(p.slot.x, p.slot.y).multiply(TILE_SIZE),
                    position: new Point(p.position.x, p.position.y)
                  }
                });

              game = loadGame(message.map, playerPostion, otherPlayers, socket);
              startGame(game);
            } else if (!game.loading && message[0] == 'pu') {
              let [_, slotX, slotY, dirX, dirY, velocity, posX, posY] = message;
              let slot = new Point(slotX, slotY).multiply(TILE_SIZE);
              let direction = new Point(dirX, dirY);
              let position = new Point(posX, posY);
              let enemy = game.enemies.get(new Enemy(slot));

              enemy.setPosition(position);
              enemy.turn(direction);
              enemy.velocity = velocity;
            } else if (!game.loading && message[0] == 'b') {
              let [_, bombX, bombY, blastRadius] = message;
              game.bombs.add(new Bomb(new Point(bombX, bombY).multiply(TILE_SIZE), blastRadius, false));
            } else if (!game.loading && message[0] == 'bi') {
              let [_, bombX, bombY] = message;
              let bomb = game.bombs.get(new Point(bombX, bombY).multiply(TILE_SIZE));
              if (bomb) {
                bomb.state = 'ignition';
              }
            } else if (!game.loading && message[0] == 'cb') {
              let [_, crateX, crateY] = message;
              let crate = game.crates.get(new Point(crateX, crateY).multiply(TILE_SIZE));
              if (crate) {
                crate.visible = false;
              }
            } else if (!game.loading && message[0] == 'ps') {
              let [_, powerup, slotX, slotY] = message;
              game.powerups.add(new Powerup(powerup, new Point(slotX, slotY).multiply(TILE_SIZE)));
            } else if (!game.loading && message[0] == 'pc') {
              let [_, powerup, slotX, slotY] = message;
              if (powerup == 'clear') {
                game.player.powerups.clear();
              } else {
                game.player.powerups.add(new PowerupIcon(powerup));
              }
              game.powerups.delete(new Point(slotX, slotY).multiply(TILE_SIZE));
            } else if (!game.loading && message[0] == 'pg') {
              let [_, slotX, slotY] = message;
              game.powerups.delete(new Point(slotX, slotY).multiply(TILE_SIZE));
            } else if (!game.loading && message[0] == 'pb') {
              let [_, slotX, slotY] = message;
              let blastSlot = new Point(slotX, slotY);

              if (game.player.spawnPoint.equals(blastSlot)) {
                game.state = 'inactive';
              }

              let atEnemy = new Enemy(blastSlot.multiply(TILE_SIZE));
              if (game.enemies.has(atEnemy)) {
                game.enemies.delete(atEnemy);
              }

              if (game.enemies.size == 0) {
                game.state = 'inactive';
              }
            }
          }
        });
      } else {
        game = loadGame(map0);

        startGame(game);
      }
    }

    function startGame(game, skipRequestAnimation) {
      game.playerAnimator = animatePlayer(game);
      game.enemyAnimator = animateEnemies(game);
      game.bombAnimator = animateBombs(game);

      drawBackground(game);
      clearCenterBanner();

      game.startedAt = performance.now();

      // Start the first frame request
      if (!skipRequestAnimation) {
        window.requestAnimationFrame((timeStamp) => gameLoop(timeStamp, game));
      }
    }

    function stopGame(game) {
      clearInterval(game.playerAnimator);
      clearInterval(game.enemyAnimator);
      clearInterval(game.bombAnimator);
    }

    function loadGame(map, playerPosition, otherPlayers, socket) {
      let walls = new HashSet();
      let crates = new HashSet();
      let enemies = new HashSet();

      if (otherPlayers) {
        otherPlayers.forEach(otherPlayer => {
          let enemy = new Enemy(otherPlayer.slot, socket);
          enemy.setPosition(otherPlayer.position);
          enemies.add(enemy);
        });
      }

      map.forEach((row, y) => {
        row.split('').forEach((sprite, x) => {
          if (wallSprites.has(sprite)) walls.add(new StaticTile(new Point(x * TILE_SIZE, y * TILE_SIZE), sprite));
          if (sprite == 'C') crates.add(new StaticTile(new Point(x * TILE_SIZE, y * TILE_SIZE), 'C'));
          if (sprite == 'E') enemies.add(new Enemy(new Point(x * TILE_SIZE, y * TILE_SIZE)));
          if (sprite == 'P') playerPosition = new Point(TILE_SIZE * x, TILE_SIZE * y);
        });
      });

      let player = new Player(playerPosition, DOWN);

      return {
        socket: socket,
        state: 'active',
        map: map,
        player: player,
        walls: walls,
        crates: crates,
        enemies: enemies,
        bombs: new HashSet(),
        blasts: new HashSet(),
        powerups: new HashSet(),
        startedAt: null,
        timeLimitSeconds: 120
      }
    }

    function resetGame(game, map) {
      let newGame = loadGame(map);

      for (const [key, value] of Object.entries(newGame)) {
        game[key] = value;
      }
    }

    const surprisePowerUps = ['bomb', 'blast', 'speed', 'clear'];
    const powerupTypes = ['bomb', 'blast', 'speed', 'surprise'];

    class Powerup {
      type;
      sprite;
      position;
      boundingBox;

      constructor(type, position) {
        this.type = type;
        this.sprite = type + '_powerup';
        this.position = position;
        this.boundingBox = fullBoundingBox(position);
      }

      icon() {
        return new PowerupIcon(this.type);
      }

      hash() {
        return this.position.x + '#' + this.position.y;
      }
    }

    class PowerupIcon {
      type;
      icon;
      collectedAt;

      constructor(type) {
        this.type = type;
        this.icon = type + '_powerup';
        this.collectedAt = performance.now();
      }

      hash() {
        return this.type;
      }
    }

    const BOMB_POWERUP = new PowerupIcon('bomb');
    const BLAST_POWERUP = new PowerupIcon('blast');
    const SPEED_POWERUP = new PowerupIcon('speed');
    const SURPRISE_POWERUP = new PowerupIcon('surprise');

    function setupControls() {
      let linkClicked = false;
      let touchDelta = 10;
      let touchStartX = -1;
      let touchStartY = -1;
      let touchStartTime = -1;

      window.addEventListener('keydown', e => {
        // disable key repeating
        if (keys[e.key]) return;

        let key = keyHandlers.has(e.key) ? e.key : 'any';
        keyUpEvent = keyHandlers.get(key)

        keys[e.key] = true;
      });

      window.addEventListener('keyup', e => {
        if (keyUpEvent) {
          keyUpEvent.callback();
          keyUpEvent = null;
        }

        keys[e.key] = false;
      });

      window.addEventListener('blur', e => {
        keys = {};
      });

      window.addEventListener('unload', e => {
        keys = {};
      });

      window.addEventListener("touchstart", e => {
        if (e.touches) {
          if (e.touches[0].target.href) linkClicked = true;
          touchStartX = e.touches[0].pageX;
          touchStartY = e.touches[0].pageY;
          touchStartTime = performance.now();
          e.preventDefault();
        }
      });

      window.addEventListener("touchend", e => {
        let [mouseX, mouseY] = translateToCanvasPosition(touchStartX, touchStartY);
        let handlerHit = false;

        clickHandlers.forEach(({ box, callback }, key) => {
          if (mouseX >= box.position.x && mouseX < box.position.x + box.width &&
            mouseY >= box.position.y && mouseY < box.position.y + box.height) {
            handlerHit = true;
            callback();
          }
        });

        touchStartX = -1;
        touchStartY = -1;
        setArrowKey(null);

        if (handlerHit) return;

        if (performance.now() - touchStartTime < 200) {
          keys[' '] = true;
        }

        if (linkClicked) {
          linkClicked = false;
        } else {
          e.preventDefault();
        }
      });

      window.addEventListener("touchmove", e => {
        if (e.touches) {
          let touchX = e.touches[0].pageX;
          let touchY = e.touches[0].pageY;

          let dirX = touchX - touchStartX;
          let dirY = touchY - touchStartY;

          if (Math.abs(dirY) > touchDelta) {
            if (dirY > 0) setArrowKey('ArrowDown');
            else setArrowKey('ArrowUp');
          }

          if (Math.abs(dirX) > touchDelta && Math.abs(dirX) > Math.abs(dirY)) {
            if (dirX > 0) setArrowKey('ArrowRight');
            else setArrowKey('ArrowLeft');
          }

          e.preventDefault();
        }
      });

      window.addEventListener("mousemove", e => {
        let [cx, cy] = translateToCanvasPosition(e.clientX, e.clientY);

        mouseX = cx;
        mouseY = cy;
      });

      window.addEventListener('click', e => {
        clickHandlers.forEach(({ box, callback }, key) => {
          if (mouseX >= box.position.x && mouseX < box.position.x + box.width &&
            mouseY >= box.position.y && mouseY < box.position.y + box.height) {
            callback();
          }
        });
      });
    }

    function translateToCanvasPosition(x, y) {
      let cx, cy;
      let canvasRatio = gameCanvas.width / gameCanvas.height;
      let fullWidth = gameCanvas.scrollWidth;
      let realHeight = gameCanvas.scrollHeight;
      let realWidth = realHeight * canvasRatio;
      let xOffset = (fullWidth - realWidth) / 2;

      let relativeX = x - (gameCanvas.offsetLeft + xOffset);
      if (relativeX <= 0) {
        cx = 0;
      } else if (relativeX > 0 && relativeX < realWidth) {
        cx = Math.round((relativeX / realWidth) * gameCanvas.width);
      } else {
        cx = gameCanvas.width;
      }

      let relativeY = y - gameCanvas.offsetTop;
      if (relativeY <= 0) {
        cy = 0;
      } if (relativeY > 0 && relativeY < realHeight) {
        cy = Math.round((relativeY / realHeight) * gameCanvas.height);
      } else {
        cy = gameCanvas.height;
      }

      return [cx, cy];
    }

    function setArrowKey(pressedKey) {
      ['ArrowDown', 'ArrowUp', 'ArrowLeft', 'ArrowRight'].forEach(key => {
        keys[key] = key === pressedKey;
      });
    }

    function animatePlayer(game) {
      let currentFrame = 0;
      let currentAnimation = 'stand_down';

      return setInterval(function () {
        let newAnimation = getAnimation(game.player)

        if (newAnimation != currentAnimation) {
          currentFrame = 0;
          currentAnimation = newAnimation;
        } else {
          currentFrame = (currentFrame + 1) % playerAnimations[currentAnimation].length;
        }

        game.player.sprite = playerAnimations[currentAnimation][currentFrame];
      }, 100);
    }

    function animateEnemies(game) {
      let maxFrame = 10;
      let currentFrame = 0;
      let animations = game.socket ? networkEnemyAnimations : enemyAnimations;

      return setInterval(function () {
        game.enemies.forEach(enemy => {
          let animation = getAnimation(enemy);
          let frames = animations[animation];

          enemy.sprite = frames[currentFrame % frames.length];
        });

        currentFrame = (currentFrame + 1) % maxFrame;
      }, game.socket ? 100 : 200);
    }

    const bombFrames = ['bomb1', 'bomb2', 'bomb3', 'bomb2'];

    function animateBombs(game) {
      let maxFrame = 4;
      let currentFrame = 0;

      return setInterval(function () {
        game.bombs.forEach(bomb => {
          if (bomb.state == 'burning' || bomb.state == 'ignition') {
            bomb.sprite = bombFrames[currentFrame % bombFrames.length];
          }
        });

        currentFrame = (currentFrame + 1) % maxFrame;
      }, 200);
    }

    function getAnimation({ direction, velocity }) {
      let velocityStr = velocity > 0 ? 'walk' : 'stand';
      return velocityStr + '_' + direction.directionName();
    }

    function gameLoop(timeStamp, game) {
      if (!game.loading) {
        // Calculate the number of seconds passed since the last frame
        // with a maximum of 0.1 second.
        let secondsPassed = Math.min(0.1, (timeStamp - oldTimeStamp) / 1000);
        oldTimeStamp = timeStamp;

        // Keep requesting new frames
        window.requestAnimationFrame((timeStamp) => gameLoop(timeStamp, game));

        update(game, secondsPassed);
        drawGame(game, secondsPassed);

        if (game.state == 'lost') {
          drawLost(game);
        } else if (game.state == 'won') {
          drawWon(game);
        } else if (game.state == 'timeout') {
          drawTimeout(game);
        } else {
          drawUI(game, secondsPassed);
        }
      }
    }

    function update(game, secondsPassed, directionOverride, deltaOverride) {
      if (performance.now() - game.startedAt > game.timeLimitSeconds * 1000) {
        game.state = 'timeout';
      }

      if (game.state == 'active') {
        updatePlayer(game, secondsPassed, directionOverride, deltaOverride);
        updatePlayerPowerups(game);
      }

      updateEnemies(game, secondsPassed);
      updateBombs(game);
      updateBlasts(game);
    }

    function updatePlayer(game, secondsPassed, directionOverride, deltaOverride) {
      let { player, walls, crates, bombs, enemies } = game;

      let oldDirection = player.direction;
      let oldVelocity = player.velocity;
      let oldPosition = player.position;

      if (keys.ArrowUp || keys.ArrowDown || keys.ArrowLeft || keys.ArrowRight) {
        player.velocity = player.powerups.has(SPEED_POWERUP) ? POWERUP_VELOCITY : PLAYER_VELOCITY;

        if (!directionOverride) {
          if (keys.ArrowUp) player.turn(UP);
          if (keys.ArrowDown) player.turn(DOWN);
          if (keys.ArrowLeft) player.turn(LEFT);
          if (keys.ArrowRight) player.turn(RIGHT);
        } else {
          player.turn(directionOverride);
        }
      } else {
        player.velocity = 0;
      }

      if (keys[' ']) {
        // one shot
        keys[' '] = false;

        dropBomb(game);
      }

      let { direction, velocity, position } = player;
      let delta = velocity * secondsPassed;
      delta = deltaOverride && deltaOverride < delta ? deltaOverride : delta;
      player.setPosition(position.add(direction.multiply(delta)));

      var nonTransparentBombs = new HashSet(bombs.toArray().filter(b => !b.transparent));
      var obstacles;
      if (game.socket) {
        obstacles = [walls, crates, nonTransparentBombs, enemies];
      } else {
        obstacles = [walls, crates, nonTransparentBombs];
      }

      if (!game.socket && detectCollisions(player, [enemies], 'hitBox').length > 0) {
        game.state = 'lost';
        return;
      }

      let powerupHits = detectCollisions(player, [game.powerups]);

      if (powerupHits.length > 0) {
        let hit = powerupHits[0];

        if (game.socket) {
          let tilePosition = hit.position.divide(TILE_SIZE);
          game.socket.send(JSON.stringify(['cp', tilePosition.x, tilePosition.y]));
        } else {
          if (hit.type == 'surprise') {
            let type = surprisePowerUps[(Math.floor(Math.random() * surprisePowerUps.length))];
            if (type == 'clear') {
              player.powerups.clear();
            } else {
              player.powerups.add(new PowerupIcon(type));
            }
          } else {
            player.powerups.add(hit.icon());
          }
          game.powerups.delete(hit);
        }
      }

      let hits = detectCollisions(player, obstacles);

      if (hits.length > 0) {
        let hit = hits[0];

        if (direction.vertical()) {
          // colliding against obstacle
          let newY;
          if (direction.y > 0) {
            newY = hit.boundingBox.position.y - player.boundingBox.height;
          } else {
            newY = hit.boundingBox.position.y + hit.boundingBox.height;
          }

          if (Math.abs(newY - position.y) < TILE_SIZE && detectCollisions(player.atPosition(new Point(position.x, newY)), obstacles).length == 0) {
            player.setPosition(new Point(position.x, newY));

            if (hits.length == 1) {
              // sliding to the side
              if (player.position.x - hit.position.x > 0) {
                let delta = hit.position.x + hit.boundingBox.width - player.position.x;

                if (delta < hit.boundingBox.width * 0.75) {
                  update(game, secondsPassed, RIGHT, delta);
                }
              } else {
                let delta = player.position.x + player.boundingBox.width - hit.position.x;

                if (delta < hit.boundingBox.width * 0.75) {
                  update(game, secondsPassed, LEFT, delta);
                }
              }
            }
          }
        } else if (direction.horizontal()) {
          // colliding against obstacle
          let newX;
          if (direction.x > 0) {
            newX = hit.boundingBox.position.x - player.boundingBox.width;
          } else {
            newX = hit.boundingBox.position.x + hit.boundingBox.width;
          }

          if (Math.abs(newX - position.x) < TILE_SIZE && detectCollisions(player.atPosition(new Point(newX, position.y)), obstacles).length == 0) {
            player.setPosition(new Point(newX, position.y));

            if (hits.length == 1) {
              // sliding to the side
              if (player.position.y - hit.position.y > 0) {
                let delta = hit.position.y + hit.boundingBox.height - player.position.y;

                if (delta < hit.boundingBox.height * 0.75) {
                  update(game, secondsPassed, DOWN, delta);
                }
              } else {
                let delta = player.position.y + player.boundingBox.height - hit.position.y;

                if (delta < hit.boundingBox.height * 0.75) {
                  update(game, secondsPassed, UP, delta);
                }
              }
            }
          }
        }
      }

      if (game.socket && !directionOverride && (!oldDirection.equals(player.direction) || oldVelocity != player.velocity)) {
        game.socket.send(JSON.stringify(["u", player.direction.x, player.direction.y, player.velocity, player.position.x, player.position.y]));
      }
    }

    function updatePlayerPowerups(game) {
      let now = performance.now();

      game.player.powerups.forEach(powerup => {
        if ((now - powerup.collectedAt) > POWERUP_SECONDS * 1000) {
          game.player.powerups.delete(powerup);
        }
      });
    }

    function updateEnemies(game, secondsPassed) {
      let { enemies, walls, crates, bombs, player } = game;

      let obstacles;
      if (game.socket) {
        obstacles = [walls, crates, [player]];
      } else {
        obstacles = [walls, crates, bombs];
      }

      enemies.forEach(enemy => {
        if (!game.socket) {
          enemy.velocity = ENEMY_VELOCITY;
        }

        enemy.setPosition(enemy.position.add(enemy.direction.multiply(enemy.velocity * secondsPassed)));

        let otherEnemies = game.socket ? enemies.toArray().filter(e => !e.equals(enemy)) : [];
        let hits = detectCollisions(enemy, obstacles.concat([otherEnemies]));

        if (hits.length > 0) {
          let hit = hits[0];

          if (enemy.direction.vertical()) {
            let newY;
            if (enemy.direction.y > 0) {
              newY = hit.boundingBox.position.y - enemy.boundingBox.height;
            } else {
              newY = hit.boundingBox.position.y + hit.boundingBox.height;
            }

            enemy.setPosition(new Point(enemy.position.x, newY));
          } else if (enemy.direction.horizontal()) {
            let newX;
            if (enemy.direction.x > 0) {
              newX = hit.boundingBox.position.x - enemy.boundingBox.width;
            } else {
              newX = hit.boundingBox.position.x + hit.boundingBox.width;
            }

            enemy.setPosition(new Point(newX, enemy.position.y));
          }

          if (!game.socket) {
            if (enemy.direction.horizontal()) enemy.turn(Math.random() < 0.5 ? UP : DOWN);
            else if (enemy.direction.vertical()) enemy.turn(Math.random() < 0.5 ? LEFT : RIGHT);
          }
        }
      });
    }

    class Bomb {
      position;
      blastRadius;
      transparent = true;
      // animated by animateBombs when in burning and ignition state
      sprite = 'bomb1';
      state = 'burning';
      droppedAt;
      explodedAt;
      boundingBox;
      hitBox;
      ownedByPlayer;

      constructor(position, blastRadius, ownedByPlayer) {
        this.position = position;
        this.blastRadius = blastRadius;
        this.boundingBox = smallBoundingBox(position);
        this.hitBox = fullBoundingBox(position);
        this.droppedAt = performance.now();
        this.ownedByPlayer = ownedByPlayer;
      }

      hash() {
        return this.position.x + "#" + this.position.y;
      }
    }

    function dropBomb(game) {
      let maxBombs = game.player.powerups.has(BOMB_POWERUP) ? 4 : 2;
      if (game.bombs.toArray().filter(b => b.ownedByPlayer).length < maxBombs) {
        let tilePosition = game.player.position.divide(TILE_SIZE).round();
        let blastRadius = game.player.powerups.has(BLAST_POWERUP) ? 4 : 2;
        let bomb = new Bomb(tilePosition.multiply(TILE_SIZE), blastRadius, true);

        if (!game.bombs.has(bomb) && detectCollisions(bomb, [game.enemies]).length == 0) {
          if (game.socket) game.socket.send(JSON.stringify(["b", tilePosition.x, tilePosition.y, blastRadius]));
          game.bombs.add(bomb);
        }
      }
    }

    function updateBombs(game) {
      let { player, bombs } = game;
      let now = performance.now();

      bombs.forEach(bomb => {
        let timePassed = (now - bomb.droppedAt) / 1000;

        if (bomb.transparent) {
          if (detectCollisions(player, [new HashSet([bomb])], true).length == 0) {
            bomb.transparent = false;
          }
        }

        if (!game.socket && bomb.state == 'burning' && timePassed >= 3) {
          bomb.state = 'ignition';
        } else if (bomb.state == 'ignition') {
          bomb.state = 'exploding';
          bomb.explodedAt = performance.now();
          createBlast(game, bomb);
        } else if (bomb.state == 'exploding') {
          let explosionCount = Math.max(Math.floor((now - bomb.explodedAt) / 150) + 1, 1);

          if (explosionCount <= 4) {
            bomb.sprite = 'explosion' + explosionCount;
          } else {
            bombs.delete(bomb);
          }
        }
      });
    }

    class Blast {
      origin;
      startedAt;
      segments = new HashSet();

      constructor(origin) {
        this.origin = origin;
        this.startedAt = performance.now();
      }

      hash() {
        return this.origin.x + "#" + this.origin.y;
      }
    }

    class BlastSegment {
      positon;
      boundingBox;
      spritePrefix;
      sprite;

      constructor(position, spritePrefix) {
        this.position = position;
        this.boundingBox = fullBoundingBox(position);
        this.spritePrefix = spritePrefix;
        this.sprite = spritePrefix + '1';
      }

      setFrame(frame) {
        this.sprite = this.spritePrefix + frame;
      }

      hash() {
        return this.position.x + '#' + this.position.y;
      }
    }

    function createBlast(game, bomb) {
      let { player, walls, bombs, blasts, crates, enemies } = game;

      let radius = bomb.blastRadius;
      let blast = new Blast(bomb.position);

      if (!game.socket && detectCollisions(player, [[bomb]], 'hitBox').length > 0) {
        game.state = 'lost';
      }

      [UP, DOWN, LEFT, RIGHT].forEach(dir => {
        let position = blast.origin;

        for (let idx = 0; idx < radius; idx++) {
          position = position.add(dir.multiply(TILE_SIZE));

          let hits = detectCollisions(
            new BlastSegment(position),
            [[player], walls, bombs, crates, enemies],
            'hitBox'
          );

          if (hits.length > 0) {
            let hit = hits[0];

            if (!game.socket && hit instanceof Bomb && hit.state == 'burning') {
              hit.state = 'ignition';
              break;
            } else if (hit instanceof Enemy) {
              blast.segments.add(createBlastSegment(position, dir, idx, radius));
              if (!game.socket) {
                enemies.delete(hit);
                if (enemies.size == 0) {
                  game.state = 'won';
                }
              }
            } else if (hit instanceof StaticTile && hit.sprite == 'C') {
              crates.delete(hit);
              if (!game.socket && Math.random() > 0.5) {
                let type = powerupTypes[(Math.floor(Math.random() * powerupTypes.length))];
                game.powerups.add(new Powerup(type, hit.position));
              }
              blast.segments.add(createBlastSegment(position, dir, radius, radius));
              break;
            } else if (hit instanceof Player) {
              if (!game.socket) {
                game.state = 'lost';
              }
              blast.segments.add(createBlastSegment(position, dir, idx, radius));
            } else {
              // wall tiles sustain any blasts
              break;
            }
          } else {
            blast.segments.add(createBlastSegment(position, dir, idx, radius));
          }
        }
      });

      blasts.add(blast);
    }

    function createBlastSegment(position, dir, idx, radius) {
      if (idx < radius - 1) {
        return new BlastSegment(
          position,
          'blast_' + (dir.horizontal() ? 'horizontal' : 'vertical')
        );
      } else {
        return new BlastSegment(position, 'blast_' + dir.directionName());
      }
    }

    function updateBlasts(game) {
      let { blasts } = game;

      let now = performance.now();

      blasts.forEach(blast => {
        let explosionCount = Math.max(Math.floor((now - blast.startedAt) / 150) + 1, 1);

        if (explosionCount <= 4) {
          blast.segments.forEach(segment => segment.setFrame(explosionCount));
        } else {
          blasts.delete(blast);
        }
      });
    }

    function detectCollisions(entity, obstacleGroups, boxField) {
      let hits = [];

      let entityBox = (boxField && entity[boxField]) ? entity[boxField] : entity.boundingBox;

      obstacleGroups.forEach(obstacles => {
        obstacles.forEach(obstacle => {
          let obstacleBox = (boxField && obstacle[boxField]) ? obstacle[boxField] : obstacle.boundingBox;
          if (collides(entityBox, obstacleBox)) {
            hits.push(obstacle);
          }
        });
      });

      return hits;
    }

    function drawUI(game, secondsPassed) {
      // Calculate fps
      let fps = Math.round(1 / secondsPassed);

      // Clear the top part of canvas
      uiContext.clearRect(0, 0, uiCanvas.width, 24);

      // Draw number to the screen
      drawText(4, 0, 'FPS: ' + fps);

      let now = performance.now();

      // Draw game timer
      let gameDuration = Math.round((now - game.startedAt) / 1000);
      let secondsLeft = game.timeLimitSeconds - gameDuration;
      let timerText;
      if (secondsLeft > 0) {
        let minuteText = `${Math.floor(secondsLeft / 60)}`.padStart(2, ' ');
        let secondText = `${secondsLeft % 60}`.padStart(2, '0');
        timerText = minuteText + ':' + secondText;
      } else {
        timerText = '00:00';
      }

      let flickerState = Math.sin(((now - game.startedAt) / 250) * Math.PI) > 0;
      if (secondsLeft > 10 || secondsLeft <= 0 || (secondsLeft <= 10 && flickerState)) {
        drawText(0, 0, timerText, { align: ['hcenter'] });
      }

      game.player.powerups.forEach((powerup, idx) => {
        let secondsLeft = POWERUP_SECONDS - Math.round((now - powerup.collectedAt) / 1000);
        let flickerState = Math.sin(((now - powerup.collectedAt) / 250) * Math.PI) > 0;
        let x = uiCanvas.width - ((TILE_SIZE + 4) * (1 + idx));

        if (secondsLeft > 5 || (secondsLeft > 0 && secondsLeft <= 5 && flickerState)) {
          drawSprite(uiContext, 'items', new Point(x, 0), powerup.icon);

          let powerupAngleRatio = Math.PI * (1 - (secondsLeft / POWERUP_SECONDS));
          uiContext.fillStyle = "rgba(0, 0, 127, 0.4)";
          uiContext.beginPath();
          uiContext.arc(x + (TILE_SIZE / 2), TILE_SIZE / 2, TILE_SIZE / 2, Math.PI / -2 + powerupAngleRatio, Math.PI / -2 - powerupAngleRatio);
          uiContext.fill();
        }
      });
    }

    function clearCenterBanner() {
      uiContext.clearRect(0, 24, uiCanvas.width, uiCanvas.height - 48);
    }

    function drawWon(game) {
      drawCenterBanner('YOU WON!', 'green');
      drawRestartButton(game);
    }

    function drawLost(game) {
      drawCenterBanner('YOU LOST', 'orange');
      drawRestartButton(game);
    }

    function drawTimeout(game) {
      drawCenterBanner('TIME IS UP!', 'orange');
      drawRestartButton(game);
    }

    function drawWillRestart(game) {
      drawCenterBanner("GAME WILL RESTART", "orange");
    }

    function drawCenterBanner(text, background) {
      uiContext.clearRect(0, 24, uiCanvas.width, uiCanvas.height - 48);

      drawText(
        0, 0, text,
        {
          align: 'vcenter hcenter',
          border: { color: 'white', background: 'green' }
        }
      );
    }

    function drawRestartButton(game) {
      drawButton(
        0,
        LETTER_HEIGHT * 2,
        'TRY AGAIN',
        () => { restartGame(game) },
        { align: 'hcenter vcenter', key: 'r', oneShot: true }
      )
    }

    function drawButton(x, y, text, callback, opts) {
      let border = { color: 'white', background: opts.background || 'black' };
      let box = drawText(
        x,
        y,
        text,
        { align: opts.align, border: border, hPadding: 6, vPadding: 3 }
      );

      if (opts.key) {
        keyHandlers.set(opts.key, {
          callback: () => {
            if (opts.oneShot) {
              keyHandlers.delete(opts.key);
              clickHandlers.delete(box.hash());
            }
            callback();
          }
        });
      }

      clickHandlers.set(box.hash(), {
        box: box,
        callback: () => {
          if (opts.oneShot) {
            if (opts.key) keyHandlers.delete(opts.key);
            clickHandlers.delete(box.hash());
          }
          callback();
        }
      });
    }

    function restartGame(game) {
      stopGame(game);
      resetGame(game, map0);
      startGame(game, true);
    }

    function drawGame(game) {
      // Clear the entire canvas
      gameContext.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

      game.crates.forEach(crate => {
        if (crate.visible) {
          drawSprite(gameContext, 'map', crate.position, crate.sprite);
        }
      })

      game.powerups.forEach(powerup => {
        drawSprite(gameContext, 'items', powerup.position, powerup.sprite);
      });

      game.bombs.forEach(bomb => {
        drawSprite(gameContext, 'map', bomb.position, bomb.sprite);
      });

      game.blasts.forEach(blast => {
        blast.segments.forEach(segment => {
          drawSprite(gameContext, 'map', segment.position, segment.sprite);
        });
      });

      let tallSprites = [];

      game.enemies.forEach(enemy => {
        let enemySheet = game.socket ? 'bombermen' : 'enemies';
        tallSprites.push({ position: enemy.position.round(), sheet: enemySheet, sprite: enemy.sprite });
      });

      if (game.state == 'active') {
        tallSprites.push({ position: game.player.position.round(), sheet: 'bombermen', sprite: game.player.sprite });
      }

      tallSprites.sort((s1, s2) => s1.position.y > s2.position.y ? 1 : -1);

      tallSprites.forEach(s => {
        drawSprite(gameContext, s.sheet, s.position, s.sprite);
      });
    }

    function drawBackground(game) {
      game.map.forEach((row, y) => {
        row.split('').forEach((sprite, x) => {
          let finalSprite = sprite == 'C' || sprite == 'E' || sprite == 'P' ? 'G' : sprite;
          if (finalSprite != ' ') drawSprite(bgContext, 'map', (new Point(x, y)).multiply(TILE_SIZE), finalSprite);
        });
      });
    }

    function drawSprite(context, sheetName, point, sprite) {
      let sprites = sheets[sheetName];
      let [row, column] = sprites[sprite];

      let verticalOffset = sprites.height - TILE_SIZE;

      context.drawImage(
        sprites.sheet,
        column * TILE_SIZE,
        row * (TILE_SIZE + verticalOffset),
        TILE_SIZE,
        (TILE_SIZE + verticalOffset),
        point.x,
        point.y - verticalOffset,
        TILE_SIZE,
        (TILE_SIZE + verticalOffset)
      );
    }

    const LETTER_WIDTH = 8;
    const LETTER_HEIGHT = 16;

    const textMap = {};
    ' !"#$% \'()*+,-./0123456789:;<=>?'.split('').forEach((letter, idx) => {
      textMap[letter] = [idx * LETTER_WIDTH, LETTER_HEIGHT];
    });
    '@abcdefghijklmnopqrstuvwxyz[\\]'.split('').forEach((letter, idx) => {
      textMap[letter] = [idx * LETTER_WIDTH, LETTER_HEIGHT * 2];
    });

    function drawText(x, y, inText, options) {
      options = options || {};
      let hPadding = options.hPadding || 10;
      let vPadding = options.vPadding || 5;
      let text = inText.toLowerCase();
      let realX, realY;
      if (options.align && options.align.indexOf('vcenter') > -1) {
        realY = (uiCanvas.height / 2) - (LETTER_HEIGHT / 2) + y;
      } else if (options.align && options.align.indexOf('vbottom') > -1) {
        realY = uiCanvas.height - LETTER_HEIGHT + y;
      }

      if (options.align && options.align.indexOf('hcenter') > -1) {
        realX = (uiCanvas.width / 2) - (text.length * LETTER_WIDTH / 2) + x;
      } else if (options.align && options.align.indexOf('hright') > -1) {
        realX = uiCanvas.width - (text.length * LETTER_WIDTH) + x;
      }

      realX = realX || x;
      realY = realY || y;

      let finalX = realX;
      let finalY = realY;
      let width = text.length * LETTER_WIDTH;
      let height = LETTER_HEIGHT;

      if (options.border) {
        let borderRadius = options.border.radius || 5;
        finalX = finalX - hPadding;
        finalY = finalY - hPadding;
        width = width + 2 * hPadding;
        height = height + 2 * vPadding;

        uiContext.fillStyle = options.border.background || 'black';
        uiContext.beginPath();
        uiContext.roundRect(
          realX - hPadding,
          realY - vPadding,
          width,
          height,
          borderRadius
        );
        uiContext.fill();

        if (options.border.color) {
          uiContext.strokeStyle = options.border.color;
          uiContext.lineWidth = options.border.size || 2;
          uiContext.beginPath();
          uiContext.roundRect(
            realX - hPadding,
            realY - vPadding,
            width,
            height,
            borderRadius
          );
          uiContext.stroke();
        }
      }

      text.split('').forEach((letter, idx) => {
        let [sx, sy] = textMap[letter];

        uiContext.drawImage(
          letterSheet,
          sx,
          sy,
          LETTER_WIDTH,
          LETTER_HEIGHT,
          realX + (idx * LETTER_WIDTH),
          realY,
          LETTER_WIDTH,
          LETTER_HEIGHT
        );
      });

      return new BoundingBox(new Point(finalX, finalY), width, height);
    }
  </script>
</body>

</html>